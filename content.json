[{"title":"每天学一点点","url":"/2020/07/24/每天学一点点/","content":"\n每天学习一点点，每天进步一点点\n\n<!-- more -->\n\n<!-- # css\n\n# js -->\n\n## webpack性能优化\n - 资源处理跟压缩\n - 文件的按需加载\n - 开启gzip\n - 设置cdn缓存 \n  \n## [vue开发技巧](https://zhuanlan.zhihu.com/p/148562214)\n  - 路由可以进行props解耦\n  - 模板可以添加functional 进行函数式\n  - watch 可以为 函数 字符串 数组\n  - watch 要监听的多个变量通过计算属性返回对象，再监听这个对象来实现“监听多个变量”\n  - $event 事件对象的特殊变量\n  - 添加model 执行自定义绑定事件和变量\n  - 通过 @hook 进行监听生命周期和方法\n  - new Vue.extend().$mount().$el 自定义挂载"},{"title":"Object.defineProperty的descriptor","url":"/2020/07/22/Object-defineProperty的descriptor/","content":"\nObject.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象\n\n<!-- more -->\n\ndefineProperty接收三个参数\n\n**obj**:\n定义属性的对象\n\n**prop**:\n要定义或修改的属性的名称或 Symbol\n\n**descriptor**:\n定义或修改的属性描述符\n\n\n### descriptor\n  "},{"title":"监控应用程序性能","url":"/2020/07/02/测量应用程序性能/","content":"\n近年来，WEB 开发者们为缩短用户等待时间做出了一系列方案，以期「短益求短」。比如用 PWA 缓存更多可用的离线资源，让网页应用打开更快；借助 WebAssembly 规范缩小资源体积，提高执行效率。这些方案分别着眼于网络链路，前端资源处理速度等维度上，致力提高用户体验, 数据方面的性能并不能得到及时的反馈。\n\n<!-- more -->\n\n\n## 1.performance\nperformance 接口可以获取到当前页面中与性能相关的信息。它是 High Resolution Time API 的一部分，同时也融合了 Performance Timeline API、Navigation Timing API、 User Timing API 和 Resource Timing API\n\n![Image text](/img/performance.png)\n\n* memory: 字段代表JavaScript对内存的占用。\n* navigation: 在指定的时间段里发生的操作相关信息，包括页面是加载还是刷新、发生了多少次重定向等。\n* **timing**: 包含延迟相关的性能信息，性能测量开始时的时间的高精度时间戳\n\n## 2.timing 解析\n\n> 文档来自[MDN Web 文档](https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming)\n\n* redirectStart和redirectEnd: 如果页面是由redirect而来，则redirectStart和redirectEnd分别代表redirect开始和结束的时间节点,如果没有重定向，或者重定向中的一个不同源，这个值会返回0。\n\n* unloadEventStart和unloadEventEnd: 如果前一个文档和请求的文档是同一个域的，则unloadEventStart和unloadEventEnd分别代表浏览器unload前一个文档的开始和结束时间节点。否则两者都等于0。\n\n* fetchStart: 是指在浏览器发起任何请求之前的时间值，这个时间点会在检查任何应用缓存之前。\n  \n* domainLookupStart和domainLookupEnd: 分别代表DNS查询的开始和结束时间节点。如果浏览器没有进行DNS查询（比如使用了cache），则两者的值都等于fetchStart。\n\n\n* connectStart和connectEnd: 分别代表TCP建立连接和连接成功的时间节点。如果浏览器没有进行TCP连接（比如使用持久化连接webscoket），则两者都等于domainLookupEnd。\n\n* secureConnectionStart: 可选。如果页面使用HTTPS，它的值是安全连接握手之前的时刻。如果该属性不可用，则返回undefined。如果该属性可用，但没有使用HTTPS，则返回0。\n  \n* requestStart: 代表浏览器发起请求的时间节点，请求的方式可以是请求服务器、缓存、本地资源等。\n\n* responseStart和responseEnd: 分别代表浏览器收到从服务器端（或缓存、本地资源）响应回的第一个字节和最后一个字节数据的时刻。\n\n\n* domLoading: 代表浏览器开始解析html文档的时间节点。我们知道IE浏览器下的document有readyState属性，domLoading的值就等于readyState改变为loading的时间节点。\n\n\n* domInteractive: 代表浏览器解析html文档的状态为interactive时的时间节点。domInteractive并非DOMReady，它早于DOMReady触发，代表html文档解析完毕（即dom tree创建完成）但是内嵌资源（比如外链css、js等）还未加载的时间点。\n\n\n* domContentLoadedEventStart: 代表DOMContentLoaded事件触发的时间节点: 页面文档完全加载并解析完毕之后,会触发DOMContentLoaded事件，HTML文档不会等待样式文件,图片文件,子框架页面的加载(load事件可以用来检测HTML页面是否完全加载完毕(fully-loaded))。\n\n\n* domContentLoadedEventEnd: 代表DOMContentLoaded事件完成的时间节点，此刻用户可以对页面进行操作，也就是jQuery中的domready时间。\n\n\n* domComplete: html文档完全解析完毕的时间节点。\n\n\n* loadEventStart和loadEventEnd: 分别代表onload事件触发和结束的时间节点。\n\n## 相关时间计算\n\n* 白屏时间 = domloading - fetchStart\n* onload总下载时间 = loadEventEnd - fetchStart\n* request请求耗时 = responseEnd - responseStart\n* TCP链接耗时 = connectEnd - connectStart\n* DNS查询耗时 = domainLookupEnd - domainLookupStart\n* 解析dom树耗时 = domComplete - domInteractive\n* domready可操作时间 = domContentLoadedEventEnd - fetchStart","tags":["js","web","性能监控"],"categories":["web"]},{"title":"不知道的vue小技巧","url":"/2020/06/24/不知道的vue小技巧/","content":"\n在平常敲代码过程中，我们总是想更快的处理好我们的代码逻辑实现对业务，但是却写出来了大量的不好维护代码，那是因为你没有使用到好的小技巧~\n\n<!-- more -->\n\n## 1.使用.sync修饰符\n\n> 2.3.0+ 新增\n\n在[官方文档](https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6)中介绍.sync为自定义事件的一种使用方式，可以对prop进行“双向绑定”.\n\n原来的做法\n\n```\n父级组件\n<span :title=\"title\"  @updata:title=\"value => title = value\" />\n\n#子级组件\nthis.$emit('update:title', newTitle)\n\n```\n\n大家都知道vue进行对父级的直接修改会进行报错(修改是对象的值不算), 官方推荐使用的是$emit的方式来进行推送事件在父级进行修改数据，但是向上面的做法就会产生代码冗余数据也不好追踪并不能准确的知道在合适更新的数据，然后官方给出了一种定修饰符。\n\n.sync的做法\n```\n# 父级组件\n<span :title.sync=\"title\" />\n\n#子级组件\nthis.$emit('update:title', newTitle)\n```\n可以看到父级还是之前一样进行传递 prop 值无任何的操作就可以直接完成对父级数据的修改不需要父级重新赋值, .sync 的固定格式为updata:属性名。\n\n**注意：**\n\n* sync 传递值须传递一个变量执行，不然无法工作。\n* sync 传递值不可以跟表达式进行一起使用。\n\n## 2.$attrs 和 $listeners\n\n> 2.4.0 新增\n\n$attrs 获取包含了父作用域中不作为 prop 的值（不包括class和style）\n\n$listeners 获取包含了父作用域中事件监听器（不包括.native修饰符）\n\n两个都是进行获取父级的传递的值，大家基本上都会对使用的ui组件进行二次封装来尽可能符合自己的业务，但是遇到那种传递 默认的prop的值跟不同展示不同的prop的时候或者不明确需要啥值的时候 这两个方法就派上用场了（在也不用一个个传递参数了）\n\n```\n\n#父组件\n\n<childrenDialg\n  :title=\"自定义title\"\n  :width=\"40%\"\n  :dialogVisible=\"dialogVisible />\n\n\n# 子组件\n<el-dialog\n  v-bind=\"$attrs\"\n  :visible.sync=\"dialogVisible\"\n  :before-close=\"handleClose\">\n  <span>这是我展示的数据</span>\n  <span slot=\"footer\" class=\"dialog-footer\">\n    <el-button @click=\"dialogVisible = false\">取 消</el-button>\n    <el-button type=\"primary\" @click=\"dialogVisible = false\">确 定</el-button>\n  </span>\n</el-dialog>\n\n```\n\n就这样一个动态的传递参数就完成了我们可以看下打印的值\n![Image text](/img/20200702102823打印$attrs.png)\n\n\n\n**持续更新中**","tags":["vue","js"],"categories":["vue"]},{"title":"Hello","url":"/2020/06/19/hello-world/","content":"\n这是我的第一篇文章,美好生活从这里开始。\n\n<!-- more -->\n","tags":["hello"]}]