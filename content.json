{"meta":{"title":"清度|耿紫威的个人博客","subtitle":"清度|耿紫威的个人博客","description":"清度|耿紫威的个人博客(前端技术爱好者)","author":"清度","url":"https://gengziwei.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-06-23T03:33:08.299Z","updated":"2020-06-23T03:33:08.299Z","comments":true,"path":"404.html","permalink":"https://gengziwei.github.io/404","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-06-24T07:53:00.774Z","updated":"2020-06-24T07:53:00.774Z","comments":true,"path":"about/index.html","permalink":"https://gengziwei.github.io/about/","excerpt":"","text":""},{"title":"所有分类","date":"2020-06-23T03:36:01.630Z","updated":"2020-06-23T03:36:01.630Z","comments":true,"path":"categories/index.html","permalink":"https://gengziwei.github.io/categories/","excerpt":"","text":""},{"title":"","date":"2020-06-24T06:46:50.165Z","updated":"2020-06-24T06:46:50.165Z","comments":true,"path":"mylist/index.html","permalink":"https://gengziwei.github.io/mylist/","excerpt":"","text":""},{"title":"所有标签","date":"2020-06-23T04:17:06.379Z","updated":"2020-06-23T04:17:06.379Z","comments":true,"path":"tags/index.html","permalink":"https://gengziwei.github.io/tags/","excerpt":"","text":""},{"title":"音乐播放","date":"2020-06-25T09:49:18.442Z","updated":"2020-06-25T09:49:18.442Z","comments":true,"path":"music/index.html","permalink":"https://gengziwei.github.io/music/","excerpt":"","text":""}],"posts":[{"title":"监控应用程序性能","slug":"测量应用程序性能","date":"2020-07-02T06:28:33.000Z","updated":"2020-07-02T06:52:37.802Z","comments":true,"path":"2020/07/02/测量应用程序性能/","link":"","permalink":"https://gengziwei.github.io/2020/07/02/%E6%B5%8B%E9%87%8F%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/","excerpt":"近年来，WEB 开发者们为缩短用户等待时间做出了一系列方案，以期「短益求短」。比如用 PWA 缓存更多可用的离线资源，让网页应用打开更快；借助 WebAssembly 规范缩小资源体积，提高执行效率。这些方案分别着眼于网络链路，前端资源处理速度等维度上，致力提高用户体验。","text":"近年来，WEB 开发者们为缩短用户等待时间做出了一系列方案，以期「短益求短」。比如用 PWA 缓存更多可用的离线资源，让网页应用打开更快；借助 WebAssembly 规范缩小资源体积，提高执行效率。这些方案分别着眼于网络链路，前端资源处理速度等维度上，致力提高用户体验。 1.performanceperformance 接口可以获取到当前页面中与性能相关的信息。它是 High Resolution Time API 的一部分，同时也融合了 Performance Timeline API、Navigation Timing API、 User Timing API 和 Resource Timing API memory: 字段代表JavaScript对内存的占用。 navigation: 在指定的时间段里发生的操作相关信息，包括页面是加载还是刷新、发生了多少次重定向等。 timeOrigin: 性能测量开始时的时间的高精度时间戳 2.timeOrigin 解析 startTime: 有些浏览器实现为navigationStart，代表浏览器开始unload前一个页面文档的开始时间节点。比如我们当前正在浏览baidu.com，在地址栏输入google.com并回车，浏览器的执行动作依次为：unload当前文档（即baidu.com）-&gt;请求下一文档（即google.com）。navigationStart的值便是触发unload当前文档的时间节点。如果当前文档为空，则navigationStart的值等于fetchStart。 redirectStart和redirectEnd: 如果页面是由redirect而来，则redirectStart和redirectEnd分别代表redirect开始和结束的时间节点。 unloadEventStart和unloadEventEnd: 如果前一个文档和请求的文档是同一个域的，则unloadEventStart和unloadEventEnd分别代表浏览器unload前一个文档的开始和结束时间节点。否则两者都等于0。 fetchStart: 是指在浏览器发起任何请求之前的时间值。在fetchStart和domainLookupStart之间，浏览器会检查当前文档的缓存。 domainLookupStart和domainLookupEnd: 分别代表DNS查询的开始和结束时间节点。如果浏览器没有进行DNS查询（比如使用了cache），则两者的值都等于fetchStart。 connectStart和connectEnd: 分别代表TCP建立连接和连接成功的时间节点。如果浏览器没有进行TCP连接（比如使用持久化连接webscoket），则两者都等于domainLookupEnd。 secureConnectionStart: 可选。如果页面使用HTTPS，它的值是安全连接握手之前的时刻。如果该属性不可用，则返回undefined。如果该属性可用，但没有使用HTTPS，则返回0。 requestStart: 代表浏览器发起请求的时间节点，请求的方式可以是请求服务器、缓存、本地资源等。 responseStart和responseEnd: 分别代表浏览器收到从服务器端（或缓存、本地资源）响应回的第一个字节和最后一个字节数据的时刻。 domLoading: 代表浏览器开始解析html文档的时间节点。我们知道IE浏览器下的document有readyState属性，domLoading的值就等于readyState改变为loading的时间节点。 domInteractive: 代表浏览器解析html文档的状态为interactive时的时间节点。domInteractive并非DOMReady，它早于DOMReady触发，代表html文档解析完毕（即dom tree创建完成）但是内嵌资源（比如外链css、js等）还未加载的时间点。 domContentLoadedEventStart: 代表DOMContentLoaded事件触发的时间节点: 页面文档完全加载并解析完毕之后,会触发DOMContentLoaded事件，HTML文档不会等待样式文件,图片文件,子框架页面的加载(load事件可以用来检测HTML页面是否完全加载完毕(fully-loaded))。 domContentLoadedEventEnd: 代表DOMContentLoaded事件完成的时间节点，此刻用户可以对页面进行操作，也就是jQuery中的domready时间。 domComplete: html文档完全解析完毕的时间节点。 loadEventStart和loadEventEnd: 分别代表onload事件触发和结束的时间节点。","categories":[{"name":"web","slug":"web","permalink":"https://gengziwei.github.io/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"https://gengziwei.github.io/tags/js/"},{"name":"web","slug":"web","permalink":"https://gengziwei.github.io/tags/web/"},{"name":"性能监控","slug":"性能监控","permalink":"https://gengziwei.github.io/tags/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"}]},{"title":"不知道的vue小技巧","slug":"不知道的vue小技巧","date":"2020-06-24T06:28:33.000Z","updated":"2020-07-02T06:34:32.356Z","comments":true,"path":"2020/06/24/不知道的vue小技巧/","link":"","permalink":"https://gengziwei.github.io/2020/06/24/%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84vue%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"在平常敲代码过程中，我们总是想更快的处理好我们的代码逻辑实现对业务，但是却写出来了大量的不好维护代码，那是因为你没有使用到好的小技巧~","text":"在平常敲代码过程中，我们总是想更快的处理好我们的代码逻辑实现对业务，但是却写出来了大量的不好维护代码，那是因为你没有使用到好的小技巧~ 1.使用.sync修饰符 2.3.0+ 新增 在官方文档中介绍.sync为自定义事件的一种使用方式，可以对prop进行“双向绑定”. 原来的做法 12345父级组件&lt;span :title&#x3D;&quot;title&quot; @updata:title&#x3D;&quot;value &#x3D;&gt; title &#x3D; value&quot; &#x2F;&gt;#子级组件this.$emit(&#39;update:title&#39;, newTitle) 大家都知道vue进行对父级的直接修改会进行报错(修改是对象的值不算), 官方推荐使用的是$emit的方式来进行推送事件在父级进行修改数据，但是向上面的做法就会产生代码冗余数据也不好追踪并不能准确的知道在合适更新的数据，然后官方给出了一种定修饰符。 .sync的做法 12345# 父级组件&lt;span :title.sync&#x3D;&quot;title&quot; &#x2F;&gt;#子级组件this.$emit(&#39;update:title&#39;, newTitle) 可以看到父级还是之前一样进行传递 prop 值无任何的操作就可以直接完成对父级数据的修改不需要父级重新赋值, .sync 的固定格式为updata:属性名。 注意： sync 传递值须传递一个变量执行，不然无法工作。 sync 传递值不可以跟表达式进行一起使用。 2.$attrs 和 $listeners 2.4.0 新增 $attrs 获取包含了父作用域中不作为 prop 的值（不包括class和style） $listeners 获取包含了父作用域中事件监听器（不包括.native修饰符） 两个都是进行获取父级的传递的值，大家基本上都会对使用的ui组件进行二次封装来尽可能符合自己的业务，但是遇到那种传递 默认的prop的值跟不同展示不同的prop的时候或者不明确需要啥值的时候 这两个方法就派上用场了（在也不用一个个传递参数了） 1234567891011121314151617181920#父组件&lt;childrenDialg :title&#x3D;&quot;自定义title&quot; :width&#x3D;&quot;40%&quot; :dialogVisible&#x3D;&quot;dialogVisible &#x2F;&gt;# 子组件&lt;el-dialog v-bind&#x3D;&quot;$attrs&quot; :visible.sync&#x3D;&quot;dialogVisible&quot; :before-close&#x3D;&quot;handleClose&quot;&gt; &lt;span&gt;这是我展示的数据&lt;&#x2F;span&gt; &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt; &lt;el-button @click&#x3D;&quot;dialogVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt; &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;dialogVisible &#x3D; false&quot;&gt;确 定&lt;&#x2F;el-button&gt; &lt;&#x2F;span&gt;&lt;&#x2F;el-dialog&gt; 就这样一个动态的传递参数就完成了我们可以看下打印的值 持续更新中","categories":[{"name":"vue","slug":"vue","permalink":"https://gengziwei.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://gengziwei.github.io/tags/vue/"},{"name":"js","slug":"js","permalink":"https://gengziwei.github.io/tags/js/"}]},{"title":"Hello","slug":"hello-world","date":"2020-06-19T07:21:09.108Z","updated":"2020-06-23T06:00:13.910Z","comments":true,"path":"2020/06/19/hello-world/","link":"","permalink":"https://gengziwei.github.io/2020/06/19/hello-world/","excerpt":"这是我的第一篇文章,美好生活从这里开始。","text":"这是我的第一篇文章,美好生活从这里开始。","categories":[],"tags":[{"name":"hello","slug":"hello","permalink":"https://gengziwei.github.io/tags/hello/"}]}],"categories":[{"name":"web","slug":"web","permalink":"https://gengziwei.github.io/categories/web/"},{"name":"vue","slug":"vue","permalink":"https://gengziwei.github.io/categories/vue/"}],"tags":[{"name":"js","slug":"js","permalink":"https://gengziwei.github.io/tags/js/"},{"name":"web","slug":"web","permalink":"https://gengziwei.github.io/tags/web/"},{"name":"性能监控","slug":"性能监控","permalink":"https://gengziwei.github.io/tags/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"},{"name":"vue","slug":"vue","permalink":"https://gengziwei.github.io/tags/vue/"},{"name":"hello","slug":"hello","permalink":"https://gengziwei.github.io/tags/hello/"}]}