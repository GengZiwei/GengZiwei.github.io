[{"title":"不知道的vue小技巧","url":"/2020/06/24/不知道的vue小技巧/","content":"\n在平常敲代码过程中，我们总是想更快的处理好我们的代码逻辑实现对业务，但是却写出来了大量的不好维护代码，那是因为你没有使用到好的小技巧~\n\n<!-- more -->\n\n## 1.使用.sync修饰符\n\n> 2.3.0+ 新增\n\n在[官方文档](https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6)中介绍.sync为自定义事件的一种使用方式，可以对prop进行“双向绑定”.\n\n原来的做法\n\n```\n父级组件\n<span :title=\"title\"  @updata:title=\"value => title = value\" />\n\n#子级组件\nthis.$emit('update:title', newTitle)\n\n```\n\n大家都知道vue进行对父级的直接修改会进行报错(修改是对象的值不算), 官方推荐使用的是$emit的方式来进行推送事件在父级进行修改数据，但是向上面的做法就会产生代码冗余数据也不好追踪并不能准确的知道在合适更新的数据，然后官方给出了一种定修饰符。\n\n.sync的做法\n```\n# 父级组件\n<span :title.sync=\"title\" />\n\n#子级组件\nthis.$emit('update:title', newTitle)\n```\n可以看到父级还是之前一样进行传递 prop 值无任何的操作就可以直接完成对父级数据的修改不需要父级重新赋值, .sync 的固定格式为updata:属性名。\n\n**注意：**\n\n* sync 传递值须传递一个变量执行，不然无法工作。\n* sync 传递值不可以跟表达式进行一起使用。\n\n## 2.$attrs 和 $listeners\n\n> 2.4.0 新增\n\n$attrs 获取包含了父作用域中不作为 prop 的值（不包括class和style）\n\n$listeners 获取包含了父作用域中事件监听器（不包括.native修饰符）\n\n两个都是进行获取父级的传递的值，大家基本上都会对使用的ui组件进行二次封装来尽可能符合自己的业务，但是遇到那种传递 默认的prop的值跟不同展示不同的prop的时候或者不明确需要啥值的时候 这两个方法就派上用场了（在也不用一个个传递参数了）\n\n```\n\n#父组件\n\n<childrenDialg\n  :title=\"自定义title\"\n  :width=\"40%\"\n  :dialogVisible=\"dialogVisible />\n\n\n# 子组件\n<el-dialog\n  v-bind=\"$attrs\"\n  :visible.sync=\"dialogVisible\"\n  :before-close=\"handleClose\">\n  <span>这是我展示的数据</span>\n  <span slot=\"footer\" class=\"dialog-footer\">\n    <el-button @click=\"dialogVisible = false\">取 消</el-button>\n    <el-button type=\"primary\" @click=\"dialogVisible = false\">确 定</el-button>\n  </span>\n</el-dialog>\n\n```\n\n就这样一个动态的传递参数就完成了我们可以看下打印的值\n![Image text](img/)\n\n\n\n**持续更新中**","tags":["vue","js"],"categories":["vue"]},{"title":"Hello","url":"/2020/06/19/hello-world/","content":"\n这是我的第一篇文章,美好生活从这里开始。\n\n<!-- more -->\n","tags":["hello"]}]